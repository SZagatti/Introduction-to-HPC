
#define  _GNU_SOURCE


#include <stdlib.h>
#include <stdio.h> 
#include <math.h> 
#include <string.h>
#include <mpi.h>
#define MAX(x, y) ((x) > (y) ? (x) : (y))

#define ENSURE_int(i)   _Generic((i), int:   (i))
#define ENSURE_float(f) _Generic((f), float: (f))


#define MIN(a,b) (((a)<(b))?(a):(b))

#define XWIDTH 256
#define YWIDTH 256
#define MAXVAL 65535
#define KERNELSIZE 5


#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) +	\
  ( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif



// =============================================================
//  utilities for managinf pgm files
//
//  * write_pgm_image
//  * read_pgm_image
//  * swap_image
//
// =============================================================

int divisible (int numberOne, int numberTwo ) 
{
    int result;
    if (numberOne % numberTwo != 0) {
        result = (numberOne / numberTwo ) * numberTwo;
        }
    else{result= numberOne;}

    return result;
}

void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
/*
 * image        : a pointer to the memory region that contains the image
 * maxval       : either 255 or 65536
 * xsize, ysize : x and y dimensions of the image
 * image_name   : the name of the file to be written
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 
  
  // Writing header
  // The header's format is as follows, all in ASCII.
  // "whitespace" is either a blank or a TAB or a CF or a LF
  // - The Magic Number (see below the magic numbers)
  // - the image's width
  // - the height
  // - a white space
  // - the image's height
  // - a whitespace
  // - the maximum color value, which must be between 0 and 65535
  //
  // if he maximum color value is in the range [0-255], then
  // a pixel will be expressed by a single byte; if the maximum is
  // larger than 255, then 2 bytes will be needed for each pixel
  //

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;

  /* ---------------------------------------------------------------

     TYPE    MAGIC NUM     EXTENSION   COLOR RANGE
           ASCII  BINARY

     PBM   P1     P4       .pbm        [0-1]
     PGM   P2     P5       .pgm        [0-255]
     PPM   P3     P6       .ppm        [0-2^16[
  
  ------------------------------------------------------------------ */
}


void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
/*
 * image        : a pointer to the pointer that will contain the image
 * maxval       : a pointer to the int that will store the maximum intensity in the image
 * xsize, ysize : pointers to the x and y sizes
 * image_name   : the name of the file to be read
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );

  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}


void swap_image( void *image, int xsize, int ysize, int maxval )
/*
 * This routine swaps the endianism of the memory area pointed
 * to by ptr, by blocks of 2 bytes
 *
 */
{
  if ( maxval > 255 )
    {
      // pgm files has the short int written in
      // big endian;
      // here we swap the content of the image from
      // one to another
      //
      unsigned int size = xsize * ysize;
      for ( int i = 0; i < size; i++ )
  	((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
    }
  return;
}

// =============================================================
//    			KERNELS         
// =============================================================

// Normalized Mean Kernel

void *Average_kernel(int ksizex, int ksizey)
{
      int i,j;
      int sx= (int)ksizex/2;
      int sy= (int)ksizey/2;
      double sum=0;
      void* ptr=0;
      double *kernel=(double*)malloc( ksizex*ksizey*sizeof(double) );   
          for (i = 0; i < ksizey; i++) {
            for (j = 0; j < ksizex; j++) {
                kernel[i*ksizex+j] = 1;
                sum += kernel[i*ksizex+j];
                }
          }

	  // normalization

          for (i = 0; i < ksizey; i++) {
            for (j = 0; j < ksizex; j++){ 
                  kernel[i*ksizex+j] /= sum; 
                  }
}
          ptr = (void*)kernel;
          return ptr;
}

// Normalized Weight Kernel

void *Weight_kernel(int ksizex, int ksizey,double w)
{
      int i,j;
      int sx= (int)ksizex/2;
      int sy= (int)ksizey/2;
      double sum=0;
      void* ptr=0;
      double *kernel=(double*)malloc( ksizex*ksizey* sizeof(double) );   
          for (i = 0; i < ksizey; i++) {
            for (j = 0; j < ksizex; j++) {
                if (i==sy && j ==sx){
		  // set central value 
                    kernel[i*ksizex+j] = w;}
                else{
		  // set other values 
                    kernel[i*ksizex+j] = (1-w)/(ksizex*ksizey-1); }
	    }
	  }
          ptr = (void*)kernel;
          return ptr;
}

// Normalized Gaussian Kernel


void *Gaussian_kernel(int ksizex, int ksizey)
{
      int i,j;
      int sx= (int)ksizex/2;
      int sy= (int)ksizey/2;
      double sum=0;
      void* ptr=0;
      double *kernel=(double*)malloc( ksizex*ksizey* sizeof(double) );   
          for (i = 0; i < ksizey; i++) {
            for (j = 0; j < ksizex; j++) {
                double x = i - (ksizey - 1) / 2.0;
                double y = j - (ksizex - 1) / 2.0;
                kernel[i*ksizex+j] = 1 * exp(((pow(x, 2) + pow(y, 2)) / ((2 * pow(MAX(sx,sy), 2)))) * (-1));
                sum += kernel[i*ksizex+j];
                }
          }
	  // normalization
          for (i = 0; i < ksizey; i++) {
            for (j = 0; j < ksizex; j++){ 
                  kernel[i*ksizex+j] /= sum; 
                  }
}
          ptr = (void*)kernel;
          return ptr;
}

// =============================================================
// 			MAIN
// =============================================================

int main( int argc, char **argv ) 
{ 
    if ( argc <5) {
    fprintf (stderr , " Usage : mpi -np n %s name_of_the_image kernel_size(x y) type_of_kernel(0 for average, 1 for weight, 2 for gaussian) weight_kernel(only in case of weight kernel) \n", argv[0] ) ;
    exit(-1) ;
  }

// times 
    double start_time, end_time;   
    int myid , numprocs , proc ;
    MPI_Status status;
    MPI_Request request;

start_time = MPI_Wtime();

// master process
    int master = 0;
    int tag = 0;

    int xsize;
    int ysize;
    int maxval;
    int ksizex;
    int ksizey;
    double w;
    char image_input[50];
    char image_output[50];

    // set input and output image name

    strcpy(image_input, *(argv+1)) ;  
    strcat(image_input, ".pgm");
    strcpy(image_output, *(argv+1)) ;
    strcat(image_output, ".b") ;
    strcat(image_output, "_") ;
    strcat(image_output, *(argv+2)) ;
    strcat(image_output, "_") ;
    strcat(image_output, *(argv+3)) ;
    strcat(image_output, "x") ;
    strcat(image_output, *(argv+4)) ;
    strcat(image_output,".mpi") ;
    
    // set kernel size

    ksizex = atoi( *(argv+3) );
    ksizey = atoi( *(argv+4) );

    if ( argc > 5 ){
                w = atof(*(argv+5));
                strcat(image_output, "_") ;
                strcat(image_output, "<") ;
                strcat(image_output, *(argv+5)) ;
                strcat(image_output, ">") ;int pippo;
		char str[1];
                w = atof(*(argv+5));
		pippo=(int)(w*10);
		sprintf(str, "%d", pippo);
                strcat(image_output, "<") ;
                strcat(image_output, "_") ;
		strcat(image_output, "0") ;
                strcat(image_output, str) ;
                strcat(image_output, ">") ;
	  }
            
    strcat(image_output, ".pgm");
  
    unsigned short int *M= (unsigned short int *)malloc(sizeof(unsigned short int));
    unsigned short int *N;
    double* kernel;
   
    if (strcmp(*(argv+2) ,"2")==0){
       		kernel=Gaussian_kernel(ksizex,ksizey);}
    if (strcmp(*(argv+2) ,"0")==0){
       		kernel=Average_kernel(ksizex,ksizey); }
    if (strcmp(*(argv+2) ,"1")==0){
       		kernel=Weight_kernel(ksizex,ksizey,w);}

    MPI_Init(&argc,&argv);
    MPI_Comm_size(MPI_COMM_WORLD,&numprocs);
    MPI_Comm_rank(MPI_COMM_WORLD,&myid);
  
    int sx= (int)ksizex/2;
    int sy= (int)ksizey/2;
    int i,j;
    int xsize_old,ysize_old;


    double summ =0;
    double sum =0;
 
    int dims[2];
    int periods[2];
    int coords[2];
    int p_row,p_col;

    dims[0]=0;
    dims[1]=0;
    periods[0]=0;
    periods[1]=0;
    int reorder= 0;

 	
    MPI_Comm nc;
    MPI_Dims_create(numprocs,2,dims);

    MPI_Cart_create(MPI_COMM_WORLD,2,dims,periods,reorder,&nc);
    MPI_Cart_coords(nc,myid,2,coords);
    p_row=dims[0];
    p_col=dims[1];
    
    
    if (myid==0){
        
    	read_pgm_image((void**)&M, &maxval, &xsize_old, &ysize_old, image_input);
        
        swap_image((void*)M, xsize_old, ysize_old, maxval);
        int k=0;
       
 

        xsize=divisible(xsize_old,p_col);
        ysize=divisible(ysize_old,p_row);
	N= (unsigned short int *)malloc(xsize*ysize*sizeof(unsigned short int));
          for (int h=0; h < p_col; h++){
	       for(int f=0; f < p_row; f++){
			for(int i=h*ysize/p_col; i< (h+1)*ysize/p_col; i++){
				for (int j=f*xsize/p_row; j<(f+1)*xsize/p_row;j++){
					   N[k++]=M[i*xsize_old+j];}}}}
   }
    MPI_Bcast(&xsize_old, 1, MPI_INT,0,nc);
    MPI_Bcast(&ysize_old, 1,MPI_INT, 0,nc);
    MPI_Bcast(&xsize, 1, MPI_INT,0,nc);
    MPI_Bcast(&ysize, 1,MPI_INT, 0,nc);
    MPI_Bcast(&maxval, 1,MPI_INT, 0,nc);  
    int block_xsize=xsize/p_row;
    int block_ysize=ysize/p_col; 

    unsigned short int *local_M= (unsigned short int *)malloc(block_xsize*block_ysize*sizeof(unsigned short int));

    MPI_Scatter(N,block_xsize*block_ysize,MPI_UNSIGNED_SHORT,local_M,block_xsize*block_ysize,MPI_UNSIGNED_SHORT, 0,nc);
    

    int left,right,top,bottom,inizio_i,fine_i,inizio_j,fine_j;	

    int xsize_new;
    int ysize_new;
    
    MPI_Cart_shift(nc,1,1,&left,&right);
    
    unsigned short int *left_side=(unsigned short int *)malloc(sx*block_ysize*sizeof(unsigned short int));
    unsigned short int *right_halo=(unsigned short int *)malloc(sx*block_ysize*sizeof(unsigned short int));
    unsigned short int *right_side=(unsigned short int *)malloc(sx*block_ysize*sizeof(unsigned short int));
    unsigned short int *left_halo=(unsigned short int *)malloc(sx*block_ysize*sizeof(unsigned short int));

// NO RANK ON THE LEFT, NO RANK ON THE RIGHT

    if(left<0 && right<0){
        xsize_new=block_xsize;
        inizio_j=0;
	fine_j=xsize_new;}

// RANK ON THE LEFT, NO RANK ON THE RIGHT

    if(left>=0 && right<0){
        xsize_new=block_xsize+sx;
        inizio_j=sx;
	fine_j=xsize_new;}

// NO RANK ON THE LEFT, RANK ON THE RIGHT

    if(left<0 && right>=0){ 
        xsize_new=block_xsize+sx;
	inizio_j=0;
	fine_j=xsize_new-sx;}

// RANK ON THE LEFT, RANK ON THE RIGHT 
   
    
    if(left>=0 && right>=0){ 
        xsize_new=block_xsize+2*sx;;
	inizio_j=sx;
	fine_j=xsize_new-sx;}

    int ll=0;
   		for (int i=0;i<block_ysize;i++){
			for(int j=0;j<sx;j++){
				left_side[ll++]=local_M[i*block_xsize+j];}}
    int lr=0;
   		for (int i=0;i<block_ysize;i++){
			for(int j=block_xsize-sx;j<block_xsize;j++){
				right_side[lr++]=local_M[i*block_xsize+j];}}
   

    unsigned short int *M_med=(unsigned short int *)malloc(xsize_new*block_ysize*sizeof(unsigned short int));
    MPI_Sendrecv(left_side,sx*block_ysize,MPI_UNSIGNED_SHORT,left,0,right_halo,sx*block_ysize,MPI_UNSIGNED_SHORT,right,0,nc,&status);
    MPI_Sendrecv(right_side,sx*block_ysize,MPI_UNSIGNED_SHORT,right,0,left_halo,sx*block_ysize,MPI_UNSIGNED_SHORT,left,0,nc,&status); 
	
    
    free(right_side);
    free(left_side);
 
// NO RANK ON THE LEFT, NO RANK ON THE RIGHT

    if(left<0 && right<0){
	int k1=0;
	for (int i=0;i<block_ysize;i++){
		for(int j=0;j<block_xsize;j++){
	            M_med[i*(xsize_new)+j]=local_M[k1++];}}


   }   
// RANK ON THE LEFT, NO RANK ON THE RIGHT

    if(left>=0 && right<0){
	int k1=0;
        int k2=0;
	for (int i=0;i<block_ysize;i++){
		for(int j=0;j<sx;j++){
	            M_med[i*(xsize_new)+j]=left_halo[k1++];}
		for(int j=sx;j<xsize_new;j++){
	            M_med[i*(xsize_new)+j]=local_M[k2++];}}


   } 
   
   
// N0 RANK ON THE LEFT, RANK ON THE RIGHT

    if(left<0 && right>=0){
	int k1=0;   
	for (int i=0;i<block_ysize;i++){
		for(int j=0;j<block_xsize;j++){
	            M_med[i*(xsize_new)+j]=local_M[i*block_xsize+j];}
		for(int j=block_xsize;j<xsize_new;j++){
	            M_med[i*(xsize_new)+j]=right_halo[k1++];}}
    
  

   }  
    

// RANK ON THE LEFT, RANK ON THE RIGHT
    if(left>=0 && right>=0){
	int k1=0;  
        int k2=0;
        int k3=0; 
	for (int i=0;i<block_ysize;i++){
		for(int j=0;j<sx;j++){
	            M_med[i*(xsize_new)+j]=left_halo[k1++];}
		for(int j=sx;j<xsize_new-sx;j++){
	            M_med[i*(xsize_new)+j]=local_M[k2++];}
		for(int j=xsize_new-sx;j<xsize_new;j++){
	            M_med[i*(xsize_new)+j]=right_halo[k3++];}}
   }  
    free(right_halo);
    free(left_halo);
    
    free(local_M);


    MPI_Cart_shift(nc,0,1,&top,&bottom);

// RANK ON THE TOP, NO RANK ON THE BOTTOM

    if(top<0 && bottom<0){
        ysize_new=block_ysize;
	inizio_i=0;
        fine_i=ysize_new;}
// RANK ON THE TOP, NO RANK ON THE BOTTOM

    if(top>=0 && bottom<0){
        ysize_new=block_ysize+sy;
	inizio_i=sy;
        fine_i=ysize_new;}

// NO RANK ON THE TOP, RANK ON THE BOTTOM

    if(top<0 && bottom>=0){
        ysize_new=block_ysize+sy;
	inizio_i=0;
        fine_i=ysize_new-sy;}


// RANK ON THE TOP, RANK ON THE BOTTOM

   if(top>=0 && bottom>=0){
        ysize_new=block_ysize+2*sy;
	inizio_i=sy;
        fine_i=ysize_new-sy;}

    unsigned short int *top_side=(unsigned short int *)malloc(sy*xsize_new*sizeof(unsigned short int));
    unsigned short int *bottom_halo=(unsigned short int *)malloc(sy*xsize_new*sizeof(unsigned short int));
    unsigned short int *bottom_side=(unsigned short int *)malloc(sy*xsize_new*sizeof(unsigned short int));
    unsigned short int *top_halo=(unsigned short int *)malloc(sy*xsize_new*sizeof(unsigned short int));
    unsigned short int *local_M_end=(unsigned short int *)malloc(xsize_new*ysize_new*sizeof(unsigned short int));

    int lt=0;
    	for (int i=0;i<sy;i++){
		for(int j=0;j<xsize_new;j++){
			top_side[lt++]=M_med[i*xsize_new+j];}}
	int lb=0;
    	for (int i=block_ysize-sy;i<block_ysize;i++){
		for(int j=0;j<xsize_new;j++){
			bottom_side[lb++]=M_med[i*xsize_new+j];}}

    MPI_Sendrecv(top_side,sy*xsize_new,MPI_UNSIGNED_SHORT,top,0,bottom_halo,sy*xsize_new,MPI_UNSIGNED_SHORT,bottom,0,nc,&status);	
    MPI_Sendrecv(bottom_side,sy*xsize_new,MPI_UNSIGNED_SHORT,bottom,0,top_halo,sy*xsize_new,MPI_UNSIGNED_SHORT,top,0,nc,&status);
    free(top_side);
    free(bottom_side);
// NO RANK ON THE TOP , NO RANK ON THE BOTTOM

    if(top<0 && bottom<0){
	int k1=0;
	for (int i=0;i<block_ysize;i++){
		for(int j=0;j<block_xsize;j++){
	            local_M_end[i*(xsize_new)+j]=M_med[k1++];}}


   }   
// NO RANK ON THE TOP, RANK ON THE BOTTOM
        
    if(top<0 && bottom>=0){
	int k1=0;
        int k2=0;    
	for (int i=0;i<block_ysize;i++){
		for(int j=0;j<xsize_new;j++){
	            local_M_end[i*(xsize_new)+j]=M_med[k1++];}}
	for (int i=block_ysize;i<ysize_new;i++){
		for(int j=0;j<xsize_new;j++){
	            local_M_end[i*(xsize_new)+j]=bottom_halo[k2++];}}
    }

// RANK ON THE TOP, NO RANK ON THE BOTTOM

    if(top>=0 && bottom<0){
	int k1=0;
        int k2=0;  
 	for (int i=0;i<sy;i++){
		for(int j=0;j<xsize_new;j++){
	            local_M_end[i*(xsize_new)+j]=top_halo[k1++];}}
	for (int i=sy;i<ysize_new;i++){
		for(int j=0;j<xsize_new;j++){
	            local_M_end[i*(xsize_new)+j]=M_med[k2++];}}
 }

// RANK ON THE TOP, RANK ON THE BOTTOM

    if(top>=0 && bottom>=0){

	int k1=0;
        int k2=0; 
        int k3=0;   
	for (int i=0;i<sy;i++){
		for(int j=0;j<xsize_new;j++){
	            local_M_end[i*(xsize_new)+j]=top_halo[k1++];}}
	for (int i=sy;i<ysize_new-sy;i++){
		for(int j=0;j<xsize_new;j++){
	            local_M_end[i*(xsize_new)+j]=M_med[k2++];}}
	for (int i=ysize_new-sy;i<ysize_new;i++){
		for(int j=0;j<xsize_new;j++){
	            local_M_end[i*(xsize_new)+j]=bottom_halo[k3++];}}
  } 
    free(top_halo);
    free(bottom_halo);
    free(M_med);
  

    unsigned short int *local_M_blur=(unsigned short int *)calloc(block_xsize*block_ysize,sizeof(unsigned short int));
    int k=0;
    int k2=0; 
    for ( int i = inizio_i; i < fine_i; i++ ){
	for( int  j = inizio_j; j < fine_j; j++ ){k2=k++;
	          for( int u = -sy ; u < sy+1; u++ ){
	                for( int v = -sx ; v < sx+1; v++ ){
	                     sum+=kernel[(u+sy)*ksizex+(v+sx)];
	                     if((i+u)>= 0 && (j+v)>=0   && (i+u)<= ysize_new-1 && (j+v)<= xsize_new-1){  
					local_M_blur[k2] += local_M_end[(i+u)*xsize_new+(j+v)]*kernel[(u+sy)*ksizex+(v+sx)];
                       			summ+=kernel[(u+sy)*ksizex+(v+sx)];                                             }
                               	     						                      }}
               
			local_M_blur[k2]*=sum/summ;
			summ=0;
         		sum=0;   }}
    
    free(local_M_end);
        
  MPI_Gather(local_M_blur,block_xsize*block_ysize,MPI_UNSIGNED_SHORT,N,block_xsize*block_ysize,MPI_UNSIGNED_SHORT, 0,nc); 
  
    free(local_M_blur);

    if(myid==0){
      
       unsigned short int *M_blur= (unsigned short int *)malloc(xsize*ysize*sizeof(unsigned short int));

       int k=0;
       for (int h=0; h < p_col; h++){
	       for(int f=0; f < p_row; f++){
			for(int i=h*ysize/p_col; i< (h+1)*ysize/p_col; i++){
				for (int j=f*xsize/p_row; j<(f+1)*xsize/p_row;j++){
					   M_blur[i*xsize+j]= N[k++];}}}}
	 
        if (xsize==xsize_old && ysize==ysize_old){

        swap_image( (void*)M_blur, xsize,ysize, maxval);
        write_pgm_image((void*)M_blur, maxval, xsize,ysize,image_output);}
				
        else if (xsize!=xsize_old && ysize==ysize_old){

        unsigned short int *M_blur_finale_1= (unsigned short int *)malloc(xsize_old*ysize_old*sizeof(unsigned short int));
        unsigned short int *N_x_b_1= NULL;
	N_x_b_1=(unsigned short int *)calloc((xsize_old-xsize)*ysize_old,sizeof(unsigned short int));
 
        for ( int i = 0; i < ysize_old; i++ ){
	      for( int  j = xsize ; j < xsize_old; j++ ){
	          for( int u = -sy ; u < sy+1; u++ ){
	                for( int v = -sx ; v < sx+1; v++ ){
	                     sum+=kernel[(u+sy)*ksizex+(v+sx)];
	                     if((i+u)>= 0 && (j+v)>=0   && (i+u)<= ysize_old-1 && (j+v)<= xsize_old-1){  
					N_x_b_1[i*(xsize_old-xsize)+(j-xsize)] += M[(i+u)*xsize_old+(j+v)]*kernel[(u+sy)*ksizex+(v+sx)];
                       			summ+=kernel[(u+sy)*ksizex+(v+sx)];                                             }
                               	     						                      }}
               
			N_x_b_1[i*(xsize_old-xsize)+(j-xsize)] *=sum/summ;
			summ=0;
         		sum=0;  }}


       	int k3=0;
       	for (int i=0; i < ysize_old; i++){
	       for(int j=0; j < xsize; j++){
		      M_blur_finale_1[i*xsize_old+j]= M_blur[i*xsize+j];}
               for(int j=xsize; j < xsize_old; j++){
		      M_blur_finale_1[i*xsize_old+j]= N_x_b_1[k3++];}}

       
        swap_image( (void*)M_blur_finale_1, xsize_old,ysize_old, maxval);
        write_pgm_image((void*)M_blur_finale_1, maxval, xsize_old,ysize_old,image_output);
	free(M_blur_finale_1);
        free(N_x_b_1);}


	else if (xsize==xsize_old && ysize!=ysize_old){
        unsigned short int *M_blur_finale_2= (unsigned short int *)malloc(xsize_old*ysize_old*sizeof(unsigned short int));
	unsigned short int *N_y_b_1=NULL;
        N_y_b_1= (unsigned short int *)calloc(xsize_old*(ysize_old-ysize),sizeof(unsigned short int));
        int g=0;
        int k=0;
        int k2=0; 
        for (int i=ysize; i < ysize_old; i++){
	       for(int j=0; j < xsize_old; j++){
			for( int u = -sy ; u < sy+1; u++ ){
	        	   	for( int v = -sx ; v < sx+1; v++ ){
                                        sum+=kernel[(u+sy)*ksizex+(v+sx)]; 
	        	             	if((j+v)>=0   && (i+u)<= ysize_old-1 && (j+v)<= xsize_old-1){
					
					N_y_b_1[(i-ysize)*xsize_old+j] += M[(i+u)*xsize_old+(j+v)]*kernel[(u+sy)*ksizex+(v+sx)];
                       			 summ+=kernel[(u+sy)*ksizex+(v+sx)];                                               }}}
 
                         N_y_b_1[(i-ysize)*xsize_old+j]*=sum/summ;
			summ=0;
         		sum=0;      	     						                      
                  
    		}}
	          
        
	int k_1=0;
        int k_2=0;
       	for (int i=0; i < ysize; i++){
	       for(int j=0; j < xsize_old; j++){
		      M_blur_finale_2[i*xsize_old+j]= M_blur[i*xsize+j];}}
    	for (int i=ysize; i < ysize_old; i++){
	       for(int j=0; j < xsize_old; j++){
		      M_blur_finale_2[i*xsize_old+j]= N_y_b_1[k_1++];}}

	swap_image( (void*)M_blur_finale_2, xsize_old,ysize_old, maxval);
        write_pgm_image((void*)M_blur_finale_2, maxval, xsize_old,ysize_old,image_output);
	
	free(N_y_b_1);
        free(M_blur_finale_2);
        }

        else{
        unsigned short int *M_blur_finale_3= (unsigned short int *)malloc(xsize_old*ysize_old*sizeof(unsigned short int));
        unsigned short int *N_x_b_2= NULL;
	N_x_b_2=(unsigned short int *)calloc((xsize_old-xsize)*ysize,sizeof(unsigned short int));
	unsigned short int *N_y_b_2= NULL;
	N_y_b_2=(unsigned short int *)calloc(xsize_old*(ysize_old-ysize),sizeof(unsigned short int));
        int k=0;
        int k2=0; 
        
        for ( int i = 0; i < ysize; i++ ){
	      for( int  j = xsize ; j < xsize_old; j++ ){
	          for( int u = -sy ; u < sy+1; u++ ){
	                for( int v = -sx ; v < sx+1; v++ ){
	                     sum+=kernel[(u+sy)*ksizex+(v+sx)];
	                     if((i+u)>= 0 && (j+v)>=0   && (i+u)<= ysize_old-1 && (j+v)<= xsize_old-1){  
					N_x_b_2[i*(xsize_old-xsize)+(j-xsize)] += M[(i+u)*xsize_old+(j+v)]*kernel[(u+sy)*ksizex+(v+sx)];
                       			summ+=kernel[(u+sy)*ksizex+(v+sx)];                                             }
                               	     						                      }}
               
			N_x_b_2[i*(xsize_old-xsize)+(j-xsize)]*=sum/summ;
			summ=0;
         		sum=0;   }}

	for ( int i = ysize; i < ysize_old; i++ ){
	      for( int  j = 0; j < xsize_old; j++ ){k2=k++;
	          for( int u = -sy ; u < sy+1; u++ ){
	                for( int v = -sx ; v < sx+1; v++ ){
	                     sum+=kernel[(u+sy)*ksizex+(v+sx)];
	                     if((i+u)>= 0 && (j+v)>=0   && (i+u)<= ysize_old-1 && (j+v)<= xsize_old-1){  
					N_y_b_2[(i-ysize)*xsize_old+j] += M[(i+u)*xsize_old+(j+v)]*kernel[(u+sy)*ksizex+(v+sx)];
                       			summ+=kernel[(u+sy)*ksizex+(v+sx)];                                             }
                               	     						                      }}
               
			N_y_b_2[(i-ysize)*xsize_old+j] *=sum/summ;
			summ=0;
         		sum=0;   
    		}}

	int k_1=0;
        int k_2=0;
       	for (int i=0; i < ysize; i++){
	       for(int j=0; j < xsize; j++){
		      M_blur_finale_3[i*xsize_old+j]= M_blur[i*xsize+j];}
	       for(int j=xsize; j < xsize_old; j++){
		      M_blur_finale_3[i*xsize_old+j]= N_x_b_2[i*(xsize_old-xsize)+(j-xsize)];}}
    	for (int i=ysize; i < ysize_old; i++){
	       for(int j=0; j < xsize_old; j++){
		      M_blur_finale_3[i*xsize_old+j]= N_y_b_2[(i-ysize)*xsize_old+j];}}

    

       
        swap_image( (void*)M_blur_finale_3, xsize_old,ysize_old, maxval);
        write_pgm_image((void*)M_blur_finale_3, maxval, xsize_old,ysize_old,image_output);
	free(M_blur_finale_3);
        free(N_x_b_2);
	free(N_y_b_2);}
 
	free(M_blur);
        
        free(N);
        }
	
    end_time=MPI_Wtime();

    if (myid==0){printf ( "\n # walltime on master processor : %10.8f \n",myid, end_time - start_time ) ;}

   
    MPI_Finalize();

    free(M);
    free(kernel);
    return 0;
} 

