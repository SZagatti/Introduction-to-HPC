
#include <time.h>
#include <stdlib.h>
#include <stdio.h> 
#include <math.h> 
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sched.h>
#include <omp.h>

#define ENSURE_int(i)   _Generic((i), int:   (i))
#define ENSURE_float(f) _Generic((f), float: (f))
  
#if defined(_OPENMP)
#define CPU_TIME (clock_gettime( CLOCK_REALTIME, &ts ), (double)ts.tv_sec + (double)ts.tv_nsec * 1e-9)
  
#define CPU_TIME_th (clock_gettime( CLOCK_THREAD_CPUTIME_ID, &myts ), (double)myts.tv_sec + (double)myts.tv_nsec * 1e-9)
  
#else
  
#define CPU_TIME (clock_gettime( CLOCK_PROCESS_CPUTIME_ID, &ts ), (double)ts.tv_sec + (double)ts.tv_nsec * 1e-9)
#endif

#define ENSURE_int(i)   _Generic((i), int:   (i))
#define ENSURE_float(f) _Generic((f), float: (f))

#define MAX(x,y) (((x)<(y))?(x):(y))
#define MIN(a,b) (((a)<(b))?(a):(b))

#define XWIDTH 256
#define YWIDTH 256
#define MAXVAL 65535
#define KERNELSIZE 5


#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) +	\
  ( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif



// =============================================================
//  utilities for managinf pgm files
//
//  * write_pgm_image
//  * read_pgm_image
//  * swap_image
//
// =============================================================

void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
/*
 * image        : a pointer to the memory region that contains the image
 * maxval       : either 255 or 65536
 * xsize, ysize : x and y dimensions of the image
 * image_name   : the name of the file to be written
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 
  
  // Writing header
  // The header's format is as follows, all in ASCII.
  // "whitespace" is either a blank or a TAB or a CF or a LF
  // - The Magic Number (see below the magic numbers)
  // - the image's width
  // - the height
  // - a white space
  // - the image's height
  // - a whitespace
  // - the maximum color value, which must be between 0 and 65535
  //
  // if he maximum color value is in the range [0-255], then
  // a pixel will be expressed by a single byte; if the maximum is
  // larger than 255, then 2 bytes will be needed for each pixel
  //

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;

  /* ---------------------------------------------------------------

     TYPE    MAGIC NUM     EXTENSION   COLOR RANGE
           ASCII  BINARY

     PBM   P1     P4       .pbm        [0-1]
     PGM   P2     P5       .pgm        [0-255]
     PPM   P3     P6       .ppm        [0-2^16[
  
  ------------------------------------------------------------------ */
}


void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
/*
 * image        : a pointer to the pointer that will contain the image
 * maxval       : a pointer to the int that will store the maximum intensity in the image
 * xsize, ysize : pointers to the x and y sizes
 * image_name   : the name of the file to be read
 *
 */
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );

  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}


void swap_image( void *image, int xsize, int ysize, int maxval )
/*
 * This routine swaps the endianism of the memory area pointed
 * to by ptr, by blocks of 2 bytes
 *
 */
{
  int i;
  if ( maxval > 255 )
    {
      // pgm files has the short int written in
      // big endian;
      // here we swap the content of the image from
      // one to another
      //
      unsigned int size = xsize * ysize;
      for ( i = 0; i < size; i++ )
  	((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
    }
  return;
}



// =============================================================
//    			KERNELS         
// =============================================================

// Normalized Mean Kernel
void *Average_kernel(int ksizex, int ksizey)
{
      int i,j;
      int sx= (int)ksizex/2;
      int sy= (int)ksizey/2;
      double sum=0;
      void* ptr=0;
      double *kernel=(double*)calloc( ksizex*ksizey, sizeof(double) );    
	    for (i = 0; i < ksizey; i++) {
              for (j = 0; j < ksizex; j++) {
                 kernel[i*ksizex+j] = 1;
                 sum += kernel[i*ksizex+j];
	      }
	   }

	  // normalization
      
          for (i = 0; i < ksizey; i++) {
            for (j = 0; j < ksizex; j++){ 
                  kernel[i*ksizex+j] /= sum; 
            }
	  }
          ptr = (void*)kernel;
          return ptr;
}

// Normalized Weight Kernel
void *Weight_kernel(int ksizex, int ksizey,double w)
{
      int i,j;
      int sx = (int)ksizex/2;
      int sy = (int)ksizey/2;
      double sum=0;
      void* ptr=0;
      double *kernel=(double*)calloc( ksizex*ksizey, sizeof(double) );   
          for (i = 0; i < ksizey; i++) {
            for (j = 0; j < ksizex; j++) {
                if (i==sy && j ==sx){
	  // set central value 
                    kernel[i*ksizex+j] = w;
		}
		else{
	  // set other values 
                    kernel[i*ksizex+j] = (1-w)/(ksizex*ksizey-1);
		}
	    }
          }
          ptr = (void*)kernel;
          return ptr;
}

// Normalized Gaussian Kernel
void *Gaussian_kernel(int ksizex, int ksizey)
{
      int i,j;
      int sx= (int)ksizex/2;
      int sy= (int)ksizey/2;
      double sum=0;
      void* ptr=0;
      double *kernel=(double*)calloc( ksizex*ksizey, sizeof(double) );   
          for (i = 0; i < ksizey; i++) {
            for (j = 0; j < ksizex; j++) {
                double x = i - (ksizey - 1) / 2.0;
                double y = j - (ksizex - 1) / 2.0;
                kernel[i*ksizex+j] = 1 * exp(((pow(x, 2) + pow(y, 2)) / ((2 * pow(MAX(sx,sy), 2)))) * (-1));
                sum += kernel[i*ksizex+j];
            }
          }
	// normalization
          for (i = 0; i < ksizey; i++) {
            for (j = 0; j < ksizex; j++){ 
                  kernel[i*ksizex+j] /= sum; 
            }
	  }
          ptr = (void*)kernel;
          return ptr;
}


// =============================================================
// 			MAIN
// =============================================================
int main( int argc, char **argv ) 
{    
    // variables for the image and the kernel    
    int xsize;
    int ysize;
    int maxval;
    int ksizex;
    int ksizey;
    double w;
    char image_input[50];
    char image_output[50];

    struct  timespec ts;

    //start time  
    double tstart= CPU_TIME;

    // set input and output image name

    strcpy(image_input, *(argv+1)) ;  
    strcat(image_input, ".pgm");
    strcpy(image_output, *(argv+1)) ;
    strcat(image_output, ".b") ;
    strcat(image_output, "_") ;
    strcat(image_output, *(argv+2)) ;
    strcat(image_output, "_") ;
    strcat(image_output, *(argv+3)) ;
    strcat(image_output, "x") ;
    strcat(image_output, *(argv+4)) ;
    
    // kernel size

    ksizex = atoi( *(argv+3) );
    ksizey = atoi( *(argv+4) );

    // Error Handling
    if(ksizex%2==0 || ksizey==1 || ksizey%2==0 || ksizey==1){
    printf("#ERROR: the dimensions of the kernel must be an odd number greater than 1!\n");
    }
    
    // Handling the various cases of different number of arguments when executing the program
    // Now the number of threads can be set with the last argument
    
    int threads= omp_get_max_threads();
    if ( argc > 5 ){
		
	if(argc == 6 ){
		threads = atoi(*(argv+5));
	}
	if( argc == 6 && atof(*(argv+5))<1 ){
	        int pippo;
		char str[1];
                w = atof(*(argv+5));
		pippo=(int)(w*10);
		sprintf(str, "%d", pippo);
                strcat(image_output, "<") ;
                strcat(image_output, "_") ;
		strcat(image_output, "0") ;
                strcat(image_output, str) ;
                strcat(image_output, ">") ;
		threads= omp_get_max_threads();
	}
	if(argc>6){
		int pippo;
                char str[1];
                w = atof(*(argv+5));
                pippo=(int)(w*10);
                sprintf(str, "%d", pippo);
                strcat(image_output, "<") ;
                strcat(image_output, "_") ;
                strcat(image_output, "0") ;
                strcat(image_output, str) ;
                strcat(image_output, ">") ;
   		
		threads = atoi(*(argv+6));
     }
    }
            
    strcat(image_output, ".omp.pgm");

   // variables for the calculation 

    int sx= (int)ksizex/2;
    int sy= (int)ksizey/2;
    int i,j,u, v;
    double *kernel;
    double summ =0;
    double sum =0;
    
    // allocation of the input and output images
    unsigned short int *M= (unsigned short int *)malloc(sizeof(short int));
    read_pgm_image((void**)&M, &maxval, &xsize, &ysize, image_input);
    unsigned short int *N= (unsigned short int *)malloc(xsize*ysize*sizeof(short int));

    // The image has been read
    
    // swap the endianism
    if ( I_M_LITTLE_ENDIAN )
      swap_image((void*)M, xsize, ysize, maxval);
    
    // depending on the input a different kernel is used
    if (strcmp(*(argv+2) ,"2")==0){
       kernel=Gaussian_kernel(ksizex,ksizey);
       }
    if (strcmp(*(argv+2) ,"0")==0){
       kernel=Average_kernel(ksizex,ksizey);
       }
    if (strcmp(*(argv+2) ,"1")==0){
       kernel=Weight_kernel(ksizex,ksizey,w);
       }
    
    //calculations

    omp_set_num_threads(threads);
    #pragma omp parallel private(i, j, u, v)
    #pragma omp for schedule(static)
    for(i = 0; i < ysize; i++){ 
    
       for(j = 0; j < xsize; j++){
          
          for(u = -sy ; u < sy+1; u++){

             for(v = -sx ; v < sx+1; v++){
                          
                 sum+=kernel[(u+sy)*ksizex+(v+sx)];
	            
		    // Handling of the borders of the image    
                    if(i+u>= 0 && j+v>=0 && i+u<= ysize-1 && j+v<=xsize-1){
				
                    N[i*xsize+j] += M[(i+u)*xsize +(j+v)]*kernel[(u+sy)*ksizex+(v+sx)];        
		    summ+=kernel[(u+sy)*ksizex+(v+sx)];}
	     }
	  } 
                       
       N[i*xsize+j] *= sum/summ;
       summ=0;
       sum=0; 
       }
   }
    
    //end of calculations
                                                                        
    // swap the endianism
    if ( I_M_LITTLE_ENDIAN )
      swap_image( (void*)N, xsize, ysize, maxval);
        
    write_pgm_image((void*)N, maxval, xsize, ysize,image_output);
    //printf("The image has been written back\n");
    
    double tend = CPU_TIME;
    printf("Program took %g of wall-clock time\n", tend - tstart );
    return 0;
} 

